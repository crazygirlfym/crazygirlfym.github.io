---
layout: post
title: 机器学习面试总结
date: 2018-11-06 21:23:34.000000000 +09:00
tags: 面试总结, 机器学习 
---

在找工作的过程中，发现自己真的好多知识点没有真正掌握，所以打算重新学习整理并记录下。

----------
## **线性回归**
在线性回归中，我们假设样本的噪声符合高斯分布。
$f(x) = \sum_i^{d} x_j w_j + \epsilon$, 其中$\epsilon $ 服从标准正态分布，也就是此处的因变量也服从均值为$\sum_i^{d} x_j w_j $正态分布。

## **最小二乘估计和最大似然估计**


**最小二乘估计**，最合理的参数估计量应该使得模型能够最好的拟合样本数据，也就是估计值和观测值之差的平方和最小。
**最大似然法**，最合理的参数估计量应该使得模型中抽取该n组样本观测值的概率最大，也就是概率分布函数或者说是似然函数最大。与最小二乘法不同的是，最大似然法需要已知这个概率分布函数，这在实践中是困难的。一般假设其满足正态分布函数的特性，在这种情况下，最大似然估计和最小二乘估计相同。

懒得打字了，把图片粘过来了。。。

![](/assets/images/likehood.png)

在线性回归场景下，最小二乘法简洁高效，比梯度下降这样的迭代法方便许多，但是在最小二乘法中需要计算$X^TX$的矩阵，有可能它的逆矩阵是不存在的，这样就没有办法直接用最小二乘法，同样的当样本非常大的时候，计算矩阵的逆是非常耗时的工作。

## **指数族分布和广义线性模型**

指数族分布可以表示为指数形式的概率分布，指数族分布的一般表达式为：
$ P(y;\eta) = b(y) exp(\eta ^ T T(y) - a(\eta))$

其中$\eta$是分布的自然参数，$T(y)$是充分统计量，通常$T(y)=y$, 当参数$a, b, T$都已知的情况下，便可以获得一个以$\eta$为参数的函数族分布。


在伯努利分布的指数分布族形式中，$\eta$与伯努利分布的参数$\phi$是一个logistic函数。此外，在高斯分布的指数分布族表示形式中，$\eta$与正态分布的参数$\mu$相等。$\eta$以不同的映射概率与其他概率分布函数的参数发生联系，从而得到了不同的模型，广义线性函数正是将指数分布族中的所有成员都作为线性模型的扩展，通过各种非线性的连接函数讲线性函数映射到其他空间，从而大大扩大了线性模型可解决的问题。


## **GBDT & XGBoost**

GBDT(Gradient Boosted Decision Tree) 是一种集成模型，采用的weak learner是决策树。


![](/assets/images/gbdt_framework.png)
在GBDT中，使用平方误差训练一颗决策树$f_k$。Gradient Boosting就是在函数空间的梯度下降。

xgboost

![](/assets/images/xgboost_1.png)
![](/assets/images/xgboost_2.png)

上述过程可以分为两个子问题：

 - 如果已经分裂完成，叶子节点的取值是多少？
 - 如何分裂：贪心法，在分裂某节点的时候，只考虑当前节点分裂后，哪个分裂方案能得到最小的L

面试的时候可能遇到的问题：

 **为什么不直接用负梯度来调节参数，而是需要一个分类器来拟合呢？**

 答： 因为负梯度是在训练集上求出的，不能被泛化到测试集中，我们的参数是在一个函数空间里，不能使用SGD这样的求解方式。使用一个分类器来拟合，是一种泛化的方式。
 **特征重要度的计算方式**

 答：特征$j$的全局重要度是通过特征$j$在单颗树种的重要度的平均值来衡量：
 $\hat{J_j^2} = \frac{1}{M} \sum \hat{J_j^2}(T_m)$

特征j在单颗树种的重要度:
$\hat{J_j^2(T)} = \sum_{t=1} ^ {L-1} \hat{i_t^2}I(v_t = j)$
其中$L$为树的叶子节点的数量，$L-1$为树的非叶子节点数量，$v_t$为节点$t$相关联的特征， $i_t^2$ 是节点t分裂之后平方损失的减少值。

**xgboost相比传统的gbdt有何不同？xgboost为什么快？xgboost如何支持并行？**

答：

* 传统GBDT以CART作为基分类器，xgboost还支持线性分类器（具体工程实践的时候），这个时候xgboost相当于L1和L2正则化项的逻辑斯谛回归（分类问题）或者是线性回归（回归问题）



* 传统的GBDT在优化（觉得这里用节点分裂比较合适）是用到一阶导数问题，xgboost则对代价函数进行了二阶泰勒展开，同时用到了一阶二阶导数。xgboost还支持自定义代价函数，只要函数可以一阶和二阶求导。
* xgboost在代价函数里加入了正则项，用于控制模型的复杂度。正则项里包含了树的叶子结点个数，每个叶子结点输出的score的平方和。
* Shrinkage(缩减)，相当于学习速率，在进行完一次迭代后，会将叶子节点的权重乘上该系数，主要是为了削弱每棵树的影响，让后面有更大的学习空间。
* 列抽样（column subsampling）。xgboost借鉴了随机森林的做法，支持列抽样，不仅能降低过拟合，还能减少计算。
* 对缺失值的处理。对于特征的值有缺失的样本，xgboost能够自动学习出他的分裂方向。
* xgboost工具支持并行。boosting不是一种串行的结构吗?怎么并行的？注意xgboost的并行不是tree粒度的并行，xgboost也是一次迭代完才能进行下一次迭代的（第t次迭代的代价函数里包含了前面t-1次迭代的预测值）。xgboost的并行是在特征粒度上的。我们知道，决策树的学习最耗时的一个步骤就是对特征的值进行排序（因为要确定最佳分割点），xgboost在训练之前，预先对数据进行了排序，然后保存为block结构，后面的迭代中重复地使用这个结构，大大减小计算量。这个block结构也使得并行成为了可能，在进行节点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么各个特征的增益计算就可以开多线程进行。
* 可并行的近似直方图算法。树节点在进行分裂时，我们需要计算每个特征的每个分割点对应的增益，即用贪心法枚举所有可能的分割点。当数据无法一次载入内存或者在分布式情况下，贪心算法效率就会变得很低，所以xgboost还提出了一种可并行的近似直方图算法，用于高效地生成候选的分割点。

**gbdt是如何做分类？如何做回归的？**

答：gbdt无论是分类还是回归一直使用的都是cart回归树，不会因为我们选择任务是回归还是分类而改变，原因在于GBDT每一轮训练是在上一轮训练的基础上进行训练的。
在分类训练的时候，是针对样本X每一个可能的类都训练一个分类回归树。针对样本有三类的情况，我们实质上是在每轮训练的时候同时训练三颗树。第一颗树针对样本x的第一类，输入为(x, 0), 第二棵树针对样本x的第二类，输入(x, 1)，第三颗树针对样本x的第三类，输入为(x, 0)。生成Cart三棵树，已经对应的f1(x), f2(x), f3(x)， 那么在此类训练中，使用softmax来产生概率。

**xgboost和lightgbm的区别**

答：xgboost等传统实现是通过pre-sort + 精确查找/分位点近似查找。存在的问题是找分裂点时速度慢。lightgbm是bin&histogram近似查找。

 - xgboost采用传统的layer-wise split方式，是一层一层往下推进。在lightgbm中采用leaf-wise split，以增益为导向分裂获得更好的结果。
 - 传统的feature parallel方式是：每个worker并行找到local BSP(best split plan)，然后通过CD聚合找到一个全局的BSP,然后将instance切分，最后将切分后的instance indices广播给所有的worke。在lightgbm中，每个worker并行找到k个local BSP,然后CD汇聚后保留top2k个BSP，CD向所有的worker收集这个2k个BSP的histogram data, 计算全局的global增益，global BSP, 然后广播。
 - lightgbm从GOSS和EFB两个角度加速：GOSS（从减少样本角度）:排除大部分小梯度的样本，仅用剩下的样本计算信息增益；EFB从减少特征角度)：捆绑互斥特征，也就是他们很少同时取非零值（也就是用一个合成特征代替）
 - lightgbm有直方图做差的算法。
 - 内存上lightgbm的内存消耗是(#data*#features*1Bytes)，对特征分桶后只需要保存特征离散化之后的值，而xgboost的exact算法内存小号为2*#data*#features*4Bytes,因此xgboost既要保存原始feature的值，也要保存这个值得顺序索引，这些值需要32位的浮点数来保存。计算上的优势，预排序算法在选择好分裂特征计算分裂收益时需要遍历所有样本的特征值，时间为(#data),而直方图算法只需要遍历桶就行了，时间为(#bin)
 - lightgbm支持直接输入categorical的特征：在对离散特征分裂时，每一个取值都当做一个桶，分裂时的增益算的是“是否属于某个category”的增益，类似于one-hot编码
 - xgboost里面的直方图为什么还是比lightgbm慢：xgboost的近似直方图是每一层都动态构建直方图，因此xgboost的直方图算法不是针对某个特定的feature,而是所有feature都共享一个直方图（每个样本的权重是二阶导），所以每一层都要重新构建直方图，而lightgbm中每一个特征都有一个直方图，所以构建一次直方图就够了。

*lightgbm几个特点：*
[参考此处](https://www.hrwhisper.me/machine-learning-lightgbm/)
 - 单边梯度采样(Gradient-based One-Side Sampling (GOSS)):目的是丢弃一些对计算信息增益没有帮助的实例。为了不影响总体的数据分布，不能将梯度较小的数据直接丢弃。lightgbm采用的方法是，将要进行分裂的特征的所有取值按照绝对值大小降序排列（和xgb不同的是不需要保存排序后的结果），进行采样。
 - 互斥稀疏特征绑定(Exclusive Feature Bunding(EFB))：通过一些特征进行融合绑定在一起，可以使特征数量的大大减少，时间复杂度由O(#data*#feature)变为O(#data*#bundle),方法是通过着色问题。
 - Histogram-based Algorithm:将连续的特征映射到离散的buckets中，组成一个个bins,然后使用这些bins建立直方图。

![](/assets/images/lightgbm.png)

**生成式模型和判别式模型**

生成式模型会对$x,y$的联合分布$p(x,y)$建模
判别式模型直接对条件概率$p(y|x;\theta)$建模
![](/assets/images/discri_gen.png)

对于**判别式模型**来说求$p(y|x)$，对于未见的实例x,根据$p(y|x)$可以求得标记$y$，能直接判别出，左边这个图直接给出了判别边界。例如：要确定一只羊是山羊还是绵羊，用判别模型的方法是从历史数据中学习到模型，然后通过提取这只羊的特征来预测出这只羊是山羊、绵羊的概率。
对于**生成式模型**求$p(x,y)$,对于预测的实例，需要求出和不同标记的联合概率分布，然后大的获胜。如上图的右侧所示，并没有边界的存在。例如：利用生成模型是根据山羊的特征学习出一个山羊的模型，然后根据绵羊的特征学出绵羊的特性，然后从这只羊中提取特征，放到山羊模型中看概率是多少，再放到绵羊中概率是多少，哪个大就是哪个。

优缺点

 - 生成式方法可以还原联合概率分布$p(x,y)$，而判别式方法不行。
 - 生成式方法学习收敛速度更快，当样本容量增加时候，学习的模型可以更加快的收敛于真实的模型。
 - 当存在隐变量时候，仍可以用生成方法学习，判别式不行。
 - 判别式方法直接学习的是条件概率或者是决策函数，直接面对预测，往往学习的准确率更高。
 - 生成式模型能够解决缺失值问题。

代表模型
 - 生成式代表模型：HMM，LDA，贝叶斯
 - 判别式代表模型: K近邻、感知机、LR、最大熵模型、支持向量机、提升方法是判别模型；


## **L1&L2**正则化

 - 从梯度更新的角度

$$\frac{dL_1(w)}{dw} = sign(w), where, sign(w) = (\frac{w_1}{|w_1|}, \frac{w_2}{|w_2|}, \dots, \frac{w_m}{|w_m|})$$


![](/assets/images/reg_1.png)
 L1正则化的梯度除了0这一点之外，梯度是1或者-1，那么每一轮的迭代更新和当前的权值无关，会向着0前进。

 $ \frac{dL_2(w)}{dw} = w$

![](/assets/images/reg_2.png)
 L2正则化的梯度更新每一轮和权值有关，当权值越小时，很慢接近0，不等于0。

 - 从贝叶斯的角度

## 特征选择

### 过滤式选择
过滤式方法先对数据集进行特征选择，然后再训练学习器，特征选择过程与后续学习器无关。用一些统计量来过滤特征。

### 包裹式选择
包裹式特征选择直接把最终要使用的学习器的性能作为特征子集的评价准则。一般而言，由于包裹式特征选择方法直接针对给定学习器进行优化，因此从最终的学习性能来看，比过滤好，但是性能开销大。

### 嵌入式选择
嵌入式特征选择是将特征选择与学习器训练过程融为一体，两者在同一个优化过程完成，即在学习器训练过程中自动进行了特征选择。

## **normalization**

### batch normalization

> covariate shift是指源域(source domain)和目标域(target domain)的条件概率是一致额，其边缘概率不同。
$P_s(Y|X=x) = P_t(Y|X=x)， P_s(X) \neq P_t(X)$

在神经网络中，对于神经网络的各层输出，在经过了层内操作后，各层输出分布就会与对应的输入信号分布不同，而且差异会随着网络深度增大而加大，但每一层所指向的label仍然不变。

Batch normalization的提出就是为了解决深度网络的难以训练，在深度网络中，存在着internal covariate shift问题，由于第一层参数的改变，导致了传递给第二层的输入的分布也会发生改变，也就是说在参数更新的过程中发生了internal covariate shift，由此造成网络难以泛化，训练缓慢。

会导致什么问题呢？
* 上层参数需要不断适应新的输入数据分布，降低学习速率
* 下层输入的变化可能趋向变大或者变小，导致上层落入饱和区使得学习过早停止
* 每一层的更新都会影响到其他层，因此每层更新策略都需要很谨慎


作用

 1. 通过对输入层的batch normalization将每一层输入的方差和均值固定，减缓了internal covariate shift现象，极大地加快了网络的训练
 2. 有益于梯度在网路间的流动，减少了参数对初始值的依赖
 3. 可以使用更高的学习率训练网络，避免发散的风险
 4. 起到了正则化的作用，像dropout一样有一个随机性引入noice的过程
 5. 可以避免网络因为使用了饱和非线性激活函数陷入饱和模式。


***为什么是对 Activation Function 的输入进行 BN（即BN( Wu+b )），而非对 Hidden Layer 的每一个输入进行 BN（W*BN(u)+b）***

按照作者的解释，由于 Hidden Layer 的输入  是上一层非线性 Activation Function 的输出，在训练初期其分布还在剧烈改变，此时约束其一阶矩和二阶矩无法很好地缓解 Covariate Shift；而BN(  )的分布更接近 Gaussian Distribution，限制其一阶矩和二阶矩能使输入到 Activation Function 的值分布更加稳定。

## **激活函数&损失函数**

### 交叉熵损失

被问到的问题是为什么要选择交叉熵损失，他的优点是什么？[参考此处](https://blog.csdn.net/liweibin1994/article/details/79510237)

如果采用交叉熵的损失函数的时候，对参数的更新是
$\frac{\partial C}{\partial w_j} = \frac{1}{n} \sum_x x_j (\sigma(z) - y)$
可以看出权重的偏导数时取决于模型的输出和标签之间$y$的偏差，偏差的越大，那么学习的就会越快。如果我们采用的是均方误差这种形式

$\frac{\partial C}{\partial w_j} = (a-y) \sigma'(z)x$ 对于sigmoid这种激活函数来说，它的最大激活值才是1/4, 当sigmoid的输出接近于1的时候，曲线就变得很平滑了，就会更新缓慢。

二分类问题的交叉熵函数的本质是假设数据服从以模型输出为参数的伯努利分布的极大似然估计。对应多分类问题的交叉熵损失函数本质上为假设数据服从以模型输出为参数的多项式分部的极大似然估计。

### softmax


## **优化方法**

### **梯度下降法**
梯度下降法每次迭代更新的时候选择负梯度的方向，是最速下降一种方式，不断迭代直至达到我们的目标。

更新的时候选择负梯度方向是因为这是下降最快的方向：

假设目标函数$f(x)$有一阶连续偏导数，当前在$x_k$处搜索$f(x)$的极小值，设方向为$d$,
$f(x_k + \alpha d)  = f(x_k) + g_k ^ T d  +o(\alpha)$
要使得上式最小，则应使得$g_k ^ T d$最小，即
$g_k ^ T d = |g_k ^ T | |d| cos \theta$
当夹角为180度时最小，即负梯度方向。
### **坐标下降法**
坐标下降法属于一种非梯度优化的方法，它在每一次迭代中沿一个坐标的方向进行搜索，通过循环不同的坐标方法来达到目标函数的局部最小值，求导时只对一个维度进行求导，每次只优化一个分量。
### **牛顿法**

牛顿法是在求极值得时候利用了二阶信息，在f(x)处在$x^k$进行二阶泰勒展开：
$f(x) = f(x^k) + g_k^T(x-x^k) + \frac{1}{2}(x-x^k)^TH(x^k)(x-x^k)$

取最小值，一阶导数为0
$x^{k+1} = x^k - H_k^{-1}g_k $

对hesssian矩阵求拟比较困难，引入拟牛顿方法

### **近端梯度下降(Proximal Gradient Descent)**
近端梯度下降是一种特殊的梯度下降方法，主要用于求解目标函数不可微的最优化问题。如果目标函数在某些点是不可微的，那么该点的梯度无法求解，传统的梯度下降方法就无法使用。PG算法的思想是使用临近算子作为近似梯度，进行梯度下降。

![](/assets/images/pgd.png)

### **次梯度算法**

![](/assets/images/subgd.png)
与梯度下降算法不同的地方在于，次梯度算法并不是下降算法，每次对于参数的更新不能保证代价函数是呈单调递减的趋势。

### **深度学习中的优化方法**

 - SGD:sgd因为更新比较频繁，会造成cost function严重的震荡，但是这种震荡可能会跳到更好的局部最小值处。
 - momentum：SGD 在 ravines 的情况下容易被困住， ravines 就是曲面的一个方向比另一个方向更陡，这时 SGD 会发生震荡而迟迟不能接近极小值：

 SGD方法的一个缺点是其更新方向完全依赖于当前batch计算出的梯度，因而十分不稳定。Momentum算法借用了物理中的动量概念，它模拟的是物体运动时的惯性，即更新的时候在一定程度上保留之前更新的方向，同时利用当前batch的梯度微调最终的更新方向。这样一来，可以在一定程度上增加稳定性，从而学习地更快，并且还有一定摆脱局部最优的能力
    Momentum算法会观察历史梯度vt−1，若当前梯度的方向与历史梯度一致（表明当前样本不太可能为异常点），则会增强这个方向的梯度，若当前梯度与历史梯方向不一致，则梯度会衰减。一种形象的解释是：我们把一个球推下山，球在下坡时积聚动量，在途中变得越来越快，γ可视为空气阻力，若球的方向发生变化，则动量会衰减。
     其实就是在SGD的基础上加上$\beta V_t$，使得在梯度方向不变的维度上速度变快，梯度方向改变的维度上速度减慢，加快收敛并减少震荡。

![](/assets/images/sgd.png)
 - nesterov momentum:在计算梯度时，不是在当前位置，而是未来的位置上,可以避免走太快。
![](/assets/images/nesterov.png)
 - adagrad：独立地使用所有模型参数的学习率，缩放每个参数反比于所有梯度历史平方值总和的平方根。具有损失最大偏导的参数相应地有一个快速下降的学习率上有相对较小的下降。
$$ \theta_{t+1, i} = \theta_{t, i} - \frac{\eta}{\sqrt{G_{t, ii} + \epsilon}} \dot g_{t,i}$$
其中 $G_t$ 是个对角矩阵， (i,i) 元素就是 $t$ 时刻参数 $θ_i$ 的梯度平方和。

从训练开始积累梯度平方会导致有效学习率过早和过量的减少。



 - rmsprop：采用指数加权的平均移动方式，丢弃遥远过去的历史。RMSprop是GeoffHinton提出的一种自适应学习率方法。Adagrad会累加之前所有的梯度平方，而RMSprop仅仅是计算对应的平均值，因此可缓解Adagrad算法学习率下降较快的问题。

 - adam
 除了像 Adadelta 和 RMSprop 一样存储了过去梯度的平方 vt 的指数衰减平均值 ，也像 momentum 一样保持了过去梯度 mt 的指数衰减平均值：

如果 mt 和 vt 被初始化为 0 向量，那它们就会向 0 偏置，所以做了偏差校正，

通过计算偏差校正后的 mt 和 vt 来抵消这些偏差：

$$\hat{m_t} = \frac{m_t}{1-\beta^t_1}$$

$$\hat{v_t} = \frac{v_t}{1-\beta^t_2}$$

梯度更新：

$\theta_{t+1} = \theta_t - \frac{\eta}{\sqrt{\hat{v_t}} + \epsilon} \hat{m_t}$

## **batch size & learning rate**

*batch size增大的时候， learning rate应该如何变化？*

采用minibatch的方差为：
$Var(g) = Var(\frac{1}{m} \sum_{i=1}^m g(x_i, y_i)) = \frac{1}{m^2} Var(g(x_1, y_1) + g(x_2, y_2) + ...+ g(x_m, y_m))$

$=\frac{1}{m^2} m Var(g(x_1, y_1))$

$=\frac{1}{m} Var(g(x_1, y_1))$

因此可以将lr增大$\sqrt(m)$倍以提高训练速度

$\frac{1}{m} Var(\sqrt{m} u * lr * g(x_1, y_1)) = Var(lr * g(x_1, y_1))$

分别比较baseline和k个worker的large batch的更新公式

$$ w{t+k} = w_t - \eta \frac{1}{n}\sum_{j<k}\sum_{x \in Bj} \Delta l(x, w_{t+j})$$

$$ w{t+1} = w_t - \hat{\eta} \frac{1}{kn}\sum_{j<k}\sum_{x \in Bj} \Delta l(x, w_{t})$$

如果在这k步之内，W(t+j) ~ W(t)的话，两者近似没有太大问题，也就是linear scale rule问题不大，但在weight变化较快的时候，会有问题，尤其是模型在刚开始训练的时候，loss下特别快，weight变化很快，W(t+j) ~ W(t)就不满足。因此在初始训练阶段，一般不会直接将lr增大为k倍，而是从baseline的lr慢慢warmup到k倍，让linear scale rule不至于违背得那么明显，这也是facebook一小时训练imagenet的做法。第二个约束是lr不能无限的放大，根据上面的分析，lr太大直接沿loss切线跑得太远，导致收敛出现问题。

在合理的范围内，增大batch_size有何好处

 - 内存利用率提高了，大矩阵乘法的并行化效率最高
 - 跑完一次epoch所需要的迭代次数，对于相同数据量的处理速度进一步加快
 - 在一定范围内，一般来说batch_size越大，其确定的下降方向越准，引起训练震荡越小

盲目增大batch_size有何坏处？

 - 内存可能撑不住
 - batch_size增大到一定的程度，其确定的下降反向已经基本不再变化，可能陷入局部最小因为降低了梯度下降的随机性。 当然太小了，可能会导致loss函数震荡而不收敛。

## CNN

### 特殊的CNN网络

 - **ResNet**
![](/assets/images/resnet.png)
*它的出现是因为能够支持更深的网络，为什么呢？*

![](/assets/images/resnet_1.png)
当$w=0, b=0$的时候 不会影响到前面的学习，相当于加了层之后把之前的 copy下来，当维度不同的时候 加入一个ws, 这个简单的加法不会给网络增加额外的参数和计算量，却可以大大增加模型的训练速度，提高训练效果，并且当模型的层数加深时，这个简单的结构能良好解决退化问题。

关于残差参考[这里](https://www.zhihu.com/question/53224378)
残差网络，则是把传统网络的输出F(x)处理一下，加上输入，将F(x)+x作为最终的输出，训练目标是F(x)=H(x)-x，因此得名残差网络。



 - **Inception Network**

![](/assets/images/inception.png)

*Inception的优势是什么？*
    最大的优势在于控制了参数的同时，仍然能获得非常好的分类性能

关于inception中的1 * 1卷积

 - 图片数据天然地临近区域的数据相关性比较高，即可通过卷积操作使得相邻像素的点连在一起。在同一空间位置但不同通道的卷积核的输出结果相关性较高
 - 一个1*1的卷积可以很自然将相关性很高的，在同一空间位置但不同通道的特征连接在一起。
 - 1 * 1卷积所连接的节点的相关性是最高的，而稍微大一点尺寸的卷积， 如3*3 5*5的卷积所连接的节点相关性也很高，因此可以进一步使用一些稍大尺寸的卷积，增加特征的多样性。

### 几种操作
 - **下采样**
 - **上采样**
 - **池化**
 - **反卷积**


平移不变性(translation invariant)和旋转不变性

信号平移，响应也跟着平移，称为平移不变性。

 - CNN丢失平移不变性是下采样（Pooling 和 Stride = 2的Conv）引起的。左移或者右移2个单位对于下采样有平移不变性，而移动一个单位就失去了平移不变性。这就对应了论文的结论：“平移距离必须是二次采样率的整数倍才有平移不变性”。这里由于只有一层下采样，二次采样率（subsampling factor） 为2，所以平移2，4，6。。。单位都可以。但是在深度神经网络中，降采样有很多，导致后续的层 二次采样率很大，这样的情况下，平移不变性的可能就很小。
 - Max_Pooling其实对于平移不变性有一定的保持作用。
 - 虽然在图像识别中最后会将Feature Map展平接FC,但是既然全卷积网络也出现了平移不变性很差的情况，说明FC层不是主导因素。

### SVM
*svm是否适用于数据量大的场景？*
这个问题其实有两个层面，一个层面是，svm在分类效果上是否适合大规模数据；另外一个层面是，svm对于大规模数据训练的运算量是否太大而无法使用。对于第二个层面，我觉得陈义的回答已经很精彩了。我说一下我对第一个层面的理解。我理解SVM并不是不适合大规模数据，而应该说，SVM在小样本训练集上能够得到比其它算法好很多的结果。支持向量机之所以成为目前最常用，效果最好的分类器之一，在于其优秀的泛化能力，这是是因为其本身的优化目标是结构化风险最小，而不是经验风险最小，因此，通过margin的概念，得到对数据分布的结构化描述，因此减低了对数据规模和数据分布的要求。而大规模数据上，并没有实验和理论证明表明svm会差于其它分类器，也许只是相对其它分类器而言，领先的幅度没有那么高而已。

> 经验误差是训练集的平均损失：$R_{emp}(f) = \frac{1}{N} \sum_{i=1} ^N L(y_i, f(x_i))$。当样本容量足够大时，经验风险最小化能保证有很好的学习效果，在现实中被广泛采用。比如，极大似然估计就是模型是条件概率分布，损失函数是对数损失时经验风险最小化。但是，当样本数比较少的时候，经验风险最小化学习的效果就未必好，会产生过拟合现象。结构风险最小化是为了防止过拟合，等价于正则化。$R_{srm}(f) = \frac{1}{N} \sum_{i=1} ^N L(y_i, f(x_i)) + \lambda J(f)$。贝叶斯估计中的后验概率估计就是模型选择条件概率分布，损失函数是对数损失函数，模型复杂度由先验概率表示的结构风险最小。

SVM 可以看做是损失函数选择hinge loss, 那么目标函数就是
$\sum[1 - y_i(w \dot x_i + b)]_{+} + \lambda w^2$, 即结构风险最小。



